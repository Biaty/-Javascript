[TOC]
# 知识整理




### css
1. 


### 原生
1. forEach

### 找变量
1. 自执行函数中
```
let a = 10;
(function a(){
    a = 20;
    console.log(a) 
})()

// a = ƒ a(){
        a = 20;
        console.log(a)
    }
```

### json
> {"":""}'   
 json => 长的像对象和数组的字符串, 本质是字符串



    json 转 对象    JSON.parse()        '{}' -> {}
        // parse必须为标准格式的json格式   '{"":""}'   才能成功转化

    对象 转 json    json.stringify()   {} -> '{}'
        //副作用是 函数和undefined 的会被过滤掉

    '[]' JSON -> []数组
    '{}' JOSON-> {}对象


### jq
$.  工具方法
$()  功能方法
#### 工具方法
1. $.each  循环
```
let ary = [1,2,3,4,5]
$.each(ary,function(i,item){
     console.log(i,item)
})
```
2. $.ajax()  拿数据  请求数据
```
$.ajax({
    url:'./1.json',   // 后台给的地址 './1.json'
    success:function(d){
        console.log(d)
    }
})

// 结构
$.ajax({
    method:'post',
    url:'http://www.baidu.com/s',
    data:{

    },       
    dataType:'jsonp',
    success:function(data){
        console.log(data)
        data.foreach(item=>{
            let $li = $('<li>'+ietm.q+'</li>');
            $('#ul').append($li);
        })
    }
})

// 原生方法
fetch('./1.json').then().then()
```
3. $.extend()  浅拷贝  插件的扩展/写插件小功能
```
//obj   
let obj = {
    name:''
};
let obj2 = $.extend({},obj);
cosole.log(obj2 == obj);  // false  浅拷贝 赋值不是赋址

// ary  
let ary = [1,2,3,4];
let ary2 = $.extend(true,[],ary);   // 加个true  就代表深度克隆
ary2[2].push(5);
console.log(ary2)

```
插件的扩展
$.extend
$.fn.extend
```
$.extend({
    //扩展的方法 extend 里面写一个对象，对象的属性就是添加的方法名，值就是函数
    trimLeft:function(){    
        console.log(this);  //12345
    };
    trimLeft:function(){

    }
})
$.trimLeft('12345')

```
#### 获取
1.  height()
    innerHeight()
    scrollHeight()
2. $('#div').sublings('')    #div 的同胞元素
3. $('#div').find('apan')   #div 的后代中所有span元素

### 同步异步
> js 单线程  从上往下解读代码  会走事件调用

- 事件调用 => 把任务交给了事件引擎 ( 所有的js事件都是异步的)
- 事件堆列 => 时间任务放到堆列里
- 事件循环 => 当主线程空闲的时候执行压入的代码,执行完后再从异步队列中压入异步代码到主线程中的过程叫事件循环

> 同步:
- 代码从上往下执行,如果一个地方卡住了,下面代码就不执行了
- 利于开发维护, 上面执行完才执行下面
> 异步
- 代码从上往下执行,如果一个地方卡住了,不会阻止代码向下执行
- 定时器,所有的事件,promise

>
    主线程(先)                   异步队列(微任务 宏任务)

主线程 -> 异步队列 ->微任务(promise) -> 宏任务(定时器) -> 宏任务中的微任务

>顺序 (promise中 then 中的才是微任务, 其中的为同步,promise中的为主线程 )
- 先执行主线程的代码
- 主线程中有异步代码(定时器,promise或者事件)时,会把异步代码放到异步队列中,条件成立时,早把异步代码压入主线程中执行
- 有微任务先执行微任务,执行完后执行宏任务
- 如果宏任务中还有微任务,先执行宏任务,再执行宏任务中的微任务

#### promise
> promise  => 承诺 => 
 解决异步编程顺序问题,让异步的代码同步执行
- 异步的操作是不容易进行维护开发的,同步才利于维护
- 没有promise也能进行开发,不过维护起来麻烦点

> 介绍下promise
- 是异步编程的一种解决方法,代码有同步编程、异步编程, 同步编程是...(),异步编程是...()
- 这就牵扯到了异步队列和主线程,代码执行时,会先执行主线程的代码...()
- 是es6 的一个语法,内部有三个状态:pending(进行中)、fulfiled(已成功)、rejected(已失败), 状态改变只能进行一次,然后就状态就会冻结在这个状态,只能是从pendig->fulfiled或者pending->rejected,
- promise会返回一个对象,对象会加状态pending,resolved,rejected ,失败进catch(状态rejected),成功进then(resolved), finally 是不管层高还是失败都会进的回调函数
- promise.all ...()
- promise.race ...()
- promise.resolve ...()

> promise 的结构
```

let p = new Promise(function(resove,reject){
    resolve()
});
p.then(function(data)){
    console.log(data)
}


new Promise(function(resolve,reject){
    //主线程
    // 异步代码执行完,通过异步代码的结果去调用resolve或者reject
    // 异步代码有可能报错或者错误,如果报错或者错误就执行reject
    // 一般都是resolve(放异步的结果)
    resolve()
});
//他有一个返回值,返回值是promise对象,这个对象有then方法

// .then() 中只能查函数 不是会穿透
// 第一个then的返回值,是第二个then 的参数
then(成功函数,失败函数)   // then中包含两个函数 (成功后的回调,失败后的可以不用写)
// 第一个then
//      成功函数里面的参数就是异步的结果
// 第二个then
//      第一个then 的返回值

// 如果代码有可能会报错,下面的代码是不会执行的,如果私用try,catch
// 那么try中的代码报错会进catch,报错是不会影响后面代码执行的

try{

}catch(){

}
```
##### promise 中的 .then
>- then方法里有两个参数,一个成功resolve,一个reject

>- .then里,再return也不会报错,相当于return了一个{}
>- trow 是抛出异常  说明代码错误 进catch

> - .then 和 .catch 的返回结果没有返回值时,返回结果undefined
> - .then 和 .catch 的返回值不能是promise本身, 要不会造成死循环

> - promise resolve 的值会穿透 
>   - .then()中只能插函数 不是函数就穿透,穿透到下一项函数,没有的话直接穿透数字
>   - 如果是函数,最后log接收的是最后一个函数的返回值
#### promise.all
> const p = PRomise.all([p1],[p2],[p3])

#### promise.race

#### promise.resolve